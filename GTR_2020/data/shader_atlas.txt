//example of some shaders compiled
flat basic.vs flat.fs
gbuffers basic.vs gbuffers.fs
depth quad.vs depth.fs
multi basicMulti.vs multi.fs
deferret quad.vs deferret.fs
defferetBlend basic.vs defferetBlend.fs
ssao quad.vs ssao.fs
ssao_blur quad.vs ssao_blur.fs
probes basic.vs probes.fs
deferret_irradiance quad.vs deferret_irradiance.fs
skybox basic.vs skybox.fs
ReflectionProbes basic.vs ReflectionProbes.fs
volumetricDirectional quad.vs volumetricDirectional.fs

\basic.vs

#version 330 core

in vec3 a_vertex;
in vec3 a_normal;
in vec2 a_uv;
in vec4 a_color;

uniform vec3 u_camera_pos;
uniform mat4 u_model;
uniform mat4 u_viewprojection;

//this will store the color for the pixel shader
out vec3 v_position;
out vec3 v_world_position;
out vec3 v_normal;
out vec2 v_uv;
out vec4 v_color;

void main()
{	

	//calcule the normal in camera space (the NormalMatrix is like ViewMatrix but without traslation)
	v_normal = (u_model * vec4( a_normal, 0.0) ).xyz;
	
	//calcule the vertex in object space
	v_position = a_vertex;
	v_world_position = (u_model * vec4( v_position, 1.0) ).xyz;
	
	//store the color in the varying var to use it from the pixel shader
	v_color = a_color;

	//store the texture coordinates
	v_uv = a_uv;

	//calcule the position of the vertex using the matrices
	gl_Position = u_viewprojection * vec4( v_world_position, 1.0 );
}



\flat.fs

#version 330 core

uniform vec4 u_color;

out vec4 FragColor;

void main()
{
	FragColor = u_color;
}




\basicMulti.vs

#version 330 core

in vec3 a_vertex;
in vec3 a_normal;
in vec2 a_uv;
in vec4 a_color;


uniform vec3 u_camera_pos;
uniform mat4 u_model;
uniform mat4 u_viewprojection;
uniform mat4 u_shadow_viewproj; //NEW
uniform int u_flag;



//this will store the color for the pixel shader
out vec3 v_position;
out vec3 v_world_position;
out vec3 v_normal;
out vec2 v_uv;
out vec4 v_color;

//SHADOW
out vec4 proj_pos; //NEW



void main()
{	
	//calcule the normal in camera space (the NormalMatrix is like ViewMatrix but without traslation)
	v_normal = (u_model * vec4( a_normal, 0.0) ).xyz;
	
	//calcule the vertex in object space
	v_position = a_vertex;
	v_world_position = (u_model * vec4( v_position, 1.0) ).xyz;
	
	//store the color in the varying var to use it from the pixel shader
	v_color = a_color;

	//store the texture coordinates
	v_uv = a_uv;

	//project our 3D position to the shadowmap //NEW
	if(u_flag==1){
		proj_pos = u_shadow_viewproj * vec4( v_world_position, 1.0 );
	}
	

	//calcule the position of the vertex using the matrices
	gl_Position = u_viewprojection * vec4( v_world_position, 1.0 );
}




\multi.fs

#version 330 core
const float PI = 3.14159265359;
in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;
in vec4 proj_pos; //Para el shadow

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_time;
uniform float u_alpha_cutoff;

//PHONG
uniform vec3 u_camera_position;
uniform vec3 u_ambient_light;
uniform vec3 u_light_vector;
uniform int u_light_type;		
uniform float u_light_intensity;
uniform vec3 u_light_position;
uniform vec3 u_light_color;	
//SPOT
uniform float u_spotCosineCutoff;	
uniform float u_spotExponent;		


uniform int u_factor;
uniform sampler2D u_emissive_texture;
uniform int u_is_emissive;
uniform float u_emissive_factor;
uniform float u_light_maxdist;
uniform int u_is_oclussion;
uniform sampler2D u_oclussion;
uniform sampler2D u_roughness_texture;
uniform float u_metalic_factor;
uniform float u_roughness_factor;

//SHADOW

uniform sampler2D shadowmap;
uniform float u_shadowmap_width;
uniform float u_shadowmap_height;
uniform float u_bias;
uniform int u_flag;
uniform sampler2DShadow u_shadowmap_AA;
uniform int u_is_shadow_AA;
uniform int u_is_front_shadow;

vec3 L = vec3(0.0);
float shadow_factor = 1.0;
float NdotL=0;
vec2 shadow_uv;
float real_depth;
float att_factor=1;
float spotFactor=1;


layout(location = 0) out vec4 FragColor;


// Geometry Term: Geometry masking/shadowing due to microfacets
float GGX(float NdotV, float k){
    return NdotV / (NdotV * (1.0 - k) + k);
}
    
float G_Smith( float NdotV, float NdotL, float roughness)
{
    float k = pow(roughness + 1.0, 2.0) / 8.0;
    return GGX(NdotL, k) * GGX(NdotV, k);
}

vec3 F_Schlick( const in float VoH, const in vec3 f0)
{
    float f = pow(1.0 - VoH, 5.0);
    return f0 + (vec3(1.0) - f0) * f;
}


float D_GGX ( const in float NoH, const in float linearRoughness )
{
    float a2 = linearRoughness * linearRoughness;
    float f = (NoH * NoH) * (a2 - 1.0) + 1.0;
    return a2 / (PI * f * f);
}

vec3 specularBRDF( float roughness, vec3 f0, float NoH, float NoV, float NoL, float LoH )
{
	float a = roughness * roughness;

	// Normal Distribution Function
	float D = D_GGX( NoH, a );

    // Fresnel Function
    vec3 F = F_Schlick( LoH, f0 );

    // Visibility Function (shadowing/masking)
    float G = G_Smith( NoV, NoL, roughness );
        
    // Norm factor
    vec3 spec = D * G * F;
    spec /= (4.0 * NoL * NoV + 1e-6);

    return spec;
}

vec3 getPBR(vec3 worldpos, vec3 N, vec2 uv, vec3 color, float metalness, float roughness)
{

//now do your illumination using worldpos and the normal..
	vec3 L = normalize( u_light_position - worldpos); 
	vec3 V = normalize(u_camera_position - worldpos);
	vec3 H = normalize(L+V); //cambiado a la N

	float NoH = max( dot(N,H), 0.0 );
	float NoV = max( dot(N,V), 0.0 );
	float NoL = max( dot(N,L), 0.0 );
	float LoH = max( dot(L,H), 0.0 );
	
	

	vec3 f0 = color * metalness + (vec3(0.5) * (1.0- metalness));

	//metallic materials do not have diffuse
	vec3 diffuseColor = (1.0 - metalness) * color;
	
	//diffuseColor= vec3(1.0); 

	//compute the specular
	vec3 Fr_d = specularBRDF(  roughness, f0, NoH, NoV, NoL, LoH);
	
	//Fr_d= vec3(1.0); 

	// Here we use the Burley, but you can replace it by the Lambert.
	//float linearRoughness = pow(roughness,0.5);

	vec3 Fd_d = diffuseColor * NoL; 
	vec3 direct = Fr_d + Fd_d;
	//add diffuse and specular reflection
	
	
	
	return direct; 
}
//this is the cook torrance specular reflection model


vec3 getPointLight(vec3 light, float shadow_factor, vec2 uv, float metalness, float roughness) //POINT LIGHT
{
	vec3 N = normalize( v_normal);
	L = normalize( u_light_position - v_world_position);
	//compute distance
	float light_distance = length(u_light_position - v_world_position );

	//compute a linear attenuation factor
	att_factor = u_light_maxdist - light_distance;

	//normalize factor
	att_factor /= u_light_maxdist;

	//ignore negative values
	att_factor = max( att_factor, 0.0 );
	NdotL = clamp( dot(L,N), 0.0,1.0 );
	light += NdotL * u_light_color * u_light_intensity * att_factor;
	light +=getPBR( v_world_position,  N,  uv,light, metalness, roughness); 
	return light; 
}

vec3 getSpotLight(vec3 light,float shadow_factor, vec2 uv, float metalness, float roughness) //SPOT LIGHT
{
	L = normalize( u_light_position - v_world_position); 
	vec3 N = normalize( v_normal);
	NdotL = clamp( dot(L,N), 0.0,1.0 ); 
	vec3 D=normalize(u_light_vector);
	float spotCosine = dot(D,-L); 
	
	if (degrees(acos(spotCosine)) <= (u_spotCosineCutoff))	{	
		float spotFactor = pow(spotCosine, u_spotExponent);
		light += NdotL * u_light_color*spotFactor*u_light_intensity* shadow_factor;
		light+=getPBR( v_world_position,  N,  uv,light, metalness, roughness); 
			
	}
	
	return light;
}

vec3 getDirectionalLight(vec3 light, float shadow_factor, vec2 uv, float metalness, float roughness) //DIRECTIONAL LIGHT
{
	L = normalize(u_light_vector);
	vec3 N = normalize( v_normal);
	NdotL = clamp( dot(L,N), 0.0,1.0 ); 
	light += NdotL * u_light_color*u_light_intensity* shadow_factor;
	light +=getPBR( v_world_position,  N,  uv, light, metalness, roughness); 

	return light;
}



float getShadow(vec3 N, vec3 L) //SHADOW, get de shadow_factor
{

	//from homogeneus space to clip space
	shadow_uv = proj_pos.xy / proj_pos.w;
			
	//from clip space to uv space
	shadow_uv = shadow_uv * 0.5 + vec2(0.5);
			
	//get point depth (from -1 to 1)
	float NdotL = clamp(dot(N,L), 0.0, 1.0);
	float real_depth;
	if (u_is_front_shadow == 1){
		float adaptative_bias = u_bias * tan(acos(NdotL));
		adaptative_bias = clamp(adaptative_bias, 0.0, 1.0);
		real_depth = (proj_pos.z - adaptative_bias)/ proj_pos.w;		
	}
	else
		real_depth = (proj_pos.z - u_bias)/ proj_pos.w;		
	
	
	
	//normalize from [-1..+1] to [0..+1]
	real_depth = real_depth * 0.5 + 0.5;
			
	//read depth from depth buffer in [0..+1]
	float shadow_depth = texture2D( shadowmap, shadow_uv).x;
			
	//compute final shadow factor by comparing
				
	if( shadow_depth < real_depth - u_bias)
		shadow_factor = 0.0; 
	
	if (u_light_type == 2 ){ //directional
		//it is outside on the sides
		if( shadow_uv.x < 0.0 || shadow_uv.x > 1.0 || shadow_uv.y < 0.0 || shadow_uv.y > 1.0)
			return 1.0;

		//it is before near or behind far plane
		if(real_depth < 0.0 || real_depth > 1.0)
			return 1.0;
	}
	
	if(u_is_shadow_AA==1){
		float xOffset = 1.0/u_shadowmap_width;
		float yOffset = 1.0/u_shadowmap_height;

		float Factor = 0.0;

		for (int y = -1 ; y <= 1 ; y++) {
			for (int x = -1 ; x <= 1 ; x++) {
				vec2 Offsets = vec2(x * xOffset, y * yOffset);
				vec3 UVC = vec3(shadow_uv + Offsets, real_depth);
				Factor += texture(u_shadowmap_AA, UVC);
			}
		}

		return (0.5 + (Factor / 18.0));
	}
	else
		return shadow_factor;
}

vec3 getOclussionLight(vec3 light, vec2 uv, vec3 ambientL, int factor) //Oclussion texture
{
	if (u_is_oclussion == 1){
		ambientL *= texture2D( u_oclussion, uv * factor).x;
	}
	light += ambientL;

	return light; 
}

vec4 getEmissiveLight(vec2 uv, vec4 color, int factor) //Emissive texture
{	
	if (u_is_emissive == 1){
		color += texture2D( u_emissive_texture , uv * factor);
	}

	return color; 
}
vec3 getAmbientLightVariable() //AMBIENT LIGHT
{
	vec3 ambientLight = u_ambient_light ;
	return ambientLight;
}
void main()
{
		vec3 direct = vec3(0.0);
		vec2 uv = v_uv;
		vec4 color = u_color;
		int factor = u_factor;
		color *= texture( u_texture, uv*factor );

		if(color.a < u_alpha_cutoff)
			discard;
		
		vec3 N = normalize(v_normal);
		//PHONG
		vec3 light = vec3(0.0);
	
		vec3 ambientL = getAmbientLightVariable();
		light=getOclussionLight(light, uv, ambientL,factor);
		float roughness = (texture( u_roughness_texture, uv)* u_roughness_factor).y;
		float metallic = (texture( u_roughness_texture, uv)* u_metalic_factor).z;

		//SHADOW
		if (u_flag==1){ 
			if (u_light_type==1){  //SPOT
				vec3 vector_light = normalize( u_light_position - v_world_position); 
				shadow_factor= getShadow(N,vector_light);
			}
			if (u_light_type==2){ //DIRECTIONAL
				vec3 vector_light = normalize(u_light_vector);
				shadow_factor= getShadow(N,vector_light); 
			}
			
		}
	
		//PHONG
		
		if (u_light_type ==0){  //POINT
			light=getPointLight(light,shadow_factor,  uv,  metallic,  roughness);
			
		}
		if (u_light_type==1){  //SPOT
			light=getSpotLight(light, shadow_factor,  uv,  metallic,  roughness);
		}
		if (u_light_type==2){ //DIRECTIONAL
			light=getDirectionalLight(light, shadow_factor,  uv,  metallic,  roughness);
		
		}
		

		color.xyz *= light;

		color= getEmissiveLight( uv , color,factor);
	
		FragColor = color;
		
}
	


\depth.fs

#version 330 core

uniform vec2 u_camera_nearfar;
uniform sampler2D u_texture; //depth map
in vec2 v_uv;
out vec4 FragColor;

void main()
{
	float n = u_camera_nearfar.x;
	float f = u_camera_nearfar.y;
	float z = texture2D(u_texture,v_uv).x;
	float color = n * (z + 1.0) / (f + n - z * (f - n));
	FragColor = vec4(color);
}


\instanced.vs

#version 330 core

in vec3 a_vertex;
in vec3 a_normal;
in vec2 a_uv;

in mat4 u_model;

uniform vec3 u_camera_pos;

uniform mat4 u_viewprojection;

//this will store the color for the pixel shader
out vec3 v_position;
out vec3 v_world_position;
out vec3 v_normal;
out vec2 v_uv;

void main()
{	
	//calcule the normal in camera space (the NormalMatrix is like ViewMatrix but without traslation)
	v_normal = (u_model * vec4( a_normal, 0.0) ).xyz;
	
	//calcule the vertex in object space
	v_position = a_vertex;
	v_world_position = (u_model * vec4( a_vertex, 1.0) ).xyz;
	
	//store the texture coordinates
	v_uv = a_uv;

	//calcule the position of the vertex using the matrices
	gl_Position = u_viewprojection * vec4( v_world_position, 1.0 );
}





\quad.vs

#version 330 core

in vec3 a_vertex;
in vec2 a_uv;

out vec2 v_uv;


void main()
{	
	v_uv = a_uv;
	gl_Position = vec4( a_vertex, 1.0 );
}

\gbuffers.fs

#version 330 core
precision highp float; 

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;


uniform vec4 u_color;
uniform sampler2D u_texture;
uniform sampler2D u_roughness_texture;
uniform int u_is_roughness; 
uniform float u_time;
uniform float u_alpha_cutoff;
uniform float u_metalic_factor;
uniform float u_roughness_factor;
uniform int u_factor;

uniform sampler2D u_emissive_texture;
uniform int u_is_emissive;

uniform sampler2D u_occlusion_texture;
uniform int u_is_oclussive;

layout(location = 0) out vec4 ColorBuffer;
layout(location = 1) out vec4 NormalBuffer;
layout(location = 2) out vec4 PositionBuffer;
layout(location = 3) out vec4 Emissive_texture;


void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, uv * u_factor);
	ColorBuffer = color;
	
	if(color.a < u_alpha_cutoff)
		discard;

	NormalBuffer=vec4(v_normal*0.5+ vec3(0.5),1.0);
	PositionBuffer=vec4(v_world_position,u_factor);
	vec4 emissive  = texture(u_emissive_texture, uv);
	Emissive_texture = emissive;
	if(u_is_roughness==1){
		vec4 roughness = texture( u_roughness_texture, uv)* u_roughness_factor; //Aqui u_factor
		vec4 metallic = texture( u_roughness_texture, uv)* u_metalic_factor;	 //Aqui u_factor
		
		NormalBuffer.a=roughness.y ;//robusnes
		ColorBuffer.a=roughness.z ;	//metal
		
		vec4 occlusion = texture(u_roughness_texture, uv);
		Emissive_texture = vec4( emissive.xyz,occlusion.x );
	}
	
	
}


\deferret.fs

#version 330 core
precision highp float; 
const float PI = 3.14159265359;

//DEFERRET
uniform sampler2D u_color_texture;
uniform sampler2D u_normal_texture;
uniform sampler2D u_position_texture;
uniform sampler2D u_depth_texture;
uniform sampler2D u_emissive_texture;

uniform mat4 u_inverse_viewprojection;
uniform vec2 u_iRes; 
uniform float u_time; 


//PHONG
uniform int u_factor;
uniform vec3 u_ambient_light;
uniform vec3 u_light_position;
uniform int u_light_type;
uniform float u_light_intensity;
uniform vec3 u_light_color;
uniform float u_light_maxdist;
uniform vec3 u_light_vector;
uniform float u_spotCosineCutoff;
uniform float u_spotExponent;
uniform mat4 u_model;
uniform int u_gamma;

uniform vec3 u_camera_position;

//SHADOW
uniform sampler2D shadowmap;
uniform mat4 u_shadow_viewproj;
uniform float u_bias;
uniform int u_flag;
uniform sampler2DShadow u_shadowmap_AA;
uniform float u_shadowmap_width;
uniform float u_shadowmap_height;
uniform int u_is_shadow_AA;
uniform int u_is_front_shadow;

//SSAO
uniform sampler2D u_ao_texture;
uniform int u_is_ssao;

vec3 L = vec3(0.0);
float shadow_factor = 1.0;
float NdotL=0;
vec2 shadow_uv;
float real_depth;
float att_factor=1;
float spotFactor=1;

layout(location = 0) out vec4 FragColor;

vec3 getAmbientLight(vec2 uv) //AMBIENT LIGHT
{
	vec3 ambientLight = vec3(0.0);
	if (u_is_ssao ==1 )
	{
		//we need the uv for the pixel in screen position
		vec2 screenuv = gl_FragCoord.xy * u_iRes;

		//read the ao_factor for this pixel
		float ao_factor = texture( u_ao_texture, screenuv ).x;

		//we could play with the curve to have more control
		ao_factor = pow( ao_factor, 3.0 );

		//weight the ambient light by it
		ambientLight += u_ambient_light * ao_factor;
	}
	else 
		ambientLight += texture(u_emissive_texture, uv).w * u_ambient_light;

		
	return ambientLight;
}
// Geometry Term: Geometry masking/shadowing due to microfacets
float GGX(float NdotV, float k){
    return NdotV / (NdotV * (1.0 - k) + k);
}
    
float G_Smith( float NdotV, float NdotL, float roughness)
{
    float k = pow(roughness + 1.0, 2.0) / 8.0;
    return GGX(NdotL, k) * GGX(NdotV, k);
}

vec3 F_Schlick( const in float VoH, const in vec3 f0)
{
    float f = pow(1.0 - VoH, 5.0);
    return f0 + (vec3(1.0) - f0) * f;
}


float D_GGX ( const in float NoH, const in float linearRoughness )
{
    float a2 = linearRoughness * linearRoughness;
    float f = (NoH * NoH) * (a2 - 1.0) + 1.0;
    return a2 / (PI * f * f);
}

//this is the cook torrance specular reflection model
vec3 specularBRDF( float roughness, vec3 f0, float NoH, float NoV, float NoL, float LoH )
{
	float a = roughness * roughness;

	// Normal Distribution Function
	float D = D_GGX( NoH, a );

    // Fresnel Function
    vec3 F = F_Schlick( LoH, f0 );

    // Visibility Function (shadowing/masking)
    float G = G_Smith( NoV, NoL, roughness );
        
    // Norm factor
    vec3 spec = D * G * F;
    spec /= (4.0 * NoL * NoV + 1e-6);

    return spec;
}


vec3 getPointLight(vec3 color, float shadow_factor, vec3 worldpos, vec3 N) //POINT LIGHT
{
	vec3 lightPos = u_light_position;
	vec3 L = (lightPos - worldpos);
	float dist = length(L);
	L /= dist; 
	float NdotL = clamp(dot(N,L),0.0,1.0);

	color += NdotL * u_light_color * u_light_intensity;
	return color; 
}

float getShadow(vec4 proj_pos, vec3 N, vec3 L) //SHADOW, get de shadow_factor
{

	//from homogeneus space to clip space
	shadow_uv = proj_pos.xy / proj_pos.w;
			
	//from clip space to uv space
	shadow_uv = shadow_uv * 0.5 + vec2(0.5);
			
	//get point depth (from -1 to 1)
	float NdotL = clamp(dot(N,L), 0.0, 1.0);
	float real_depth;
	if (u_is_front_shadow == 1){
		float adaptative_bias = u_bias * tan(acos(NdotL));
		adaptative_bias = clamp(adaptative_bias, 0.0, 1.0);
		real_depth = (proj_pos.z - adaptative_bias)/ proj_pos.w;		
	}
	else
		real_depth = (proj_pos.z - u_bias)/ proj_pos.w;		
	
	
	
	//normalize from [-1..+1] to [0..+1]
	real_depth = real_depth * 0.5 + 0.5;
			
	//read depth from depth buffer in [0..+1]
	float shadow_depth = texture2D( shadowmap, shadow_uv).x;
			
	//compute final shadow factor by comparing
				
	if( shadow_depth < real_depth - u_bias)
		shadow_factor = 0.0; 
	
	if (u_light_type == 2 ){ //directional
		//it is outside on the sides
		if( shadow_uv.x < 0.0 || shadow_uv.x > 1.0 || shadow_uv.y < 0.0 || shadow_uv.y > 1.0)
			return 1.0;

		//it is before near or behind far plane
		if(real_depth < 0.0 || real_depth > 1.0)
			return 1.0;
	}
	
	if(u_is_shadow_AA==1){
		float xOffset = 1.0/u_shadowmap_width;
		float yOffset = 1.0/u_shadowmap_height;

		float Factor = 0.0;

		for (int y = -1 ; y <= 1 ; y++) {
			for (int x = -1 ; x <= 1 ; x++) {
				vec2 Offsets = vec2(x * xOffset, y * yOffset);
				vec3 UVC = vec3(shadow_uv + Offsets, real_depth);
				Factor += texture(u_shadowmap_AA, UVC);
			}
		}

		return (0.5 + (Factor / 18.0));
	}
	else
		return shadow_factor;
}

vec3 getPBR(vec3 worldpos, vec3 N, vec2 uv, vec3 color, float metalness, float roughness)
{

//now do your illumination using worldpos and the normal..
	   

	vec3 L = normalize( u_light_position - worldpos); 
	vec3 V = normalize(u_camera_position - worldpos);
	vec3 H = normalize(L+V); //cambiado a la N

	float NoH = max( dot(N,H), 0.0 );
	float NoV = max( dot(N,V), 0.0 );
	float NoL = max( dot(N,L), 0.0 );
	float LoH = max( dot(L,H), 0.0 );
	
	vec3 f0 = color * metalness + (vec3(0.5) * (1.0- metalness));

	//metallic materials do not have diffuse
	vec3 diffuseColor = (1.0 - metalness) * color;

	//compute the specular
	vec3 Fr_d = specularBRDF(  roughness, f0, NoH, NoV, NoL, LoH);

	// Here we use the Burley, but you can replace it by the Lambert.
	//float linearRoughness = pow(roughness,0.5);

	vec3 Fd_d = diffuseColor * NoL; 
	vec3 direct = Fr_d + Fd_d;
	//add diffuse and specular reflection
	
	return direct; 
}

void main()
{
	vec2 uv = gl_FragCoord.xy * u_iRes.xy; //extract uvs from pixel screenpos
	float factor = texture(u_position_texture,uv).w;
    vec3 color = texture( u_color_texture, uv * factor).xyz;
    float depth = texture( u_depth_texture, uv ).x;
    vec3 N = texture( u_normal_texture, uv ).xyz * 2.0 - 1.0;
    N = normalize(N); //always normalize in case of data loss
    vec4 screen_pos = vec4(uv.x*2.0-1.0, uv.y*2.0-1.0, depth*2.0-1.0, 1.0);
    vec4 proj_worldpos = u_inverse_viewprojection * screen_pos;
    vec3 worldpos = proj_worldpos.xyz / proj_worldpos.a;

    vec3 light  = vec3(1.0);
	light *= getAmbientLight(uv); //oclusive and ambient

	if (depth==1.0)
		discard; 
	
	//PBR
	vec3 direct = vec3(0.0);
	float metalness = texture2D( u_color_texture, uv ).w;
	float roughness = texture2D( u_normal_texture, uv ).w;

	vec4 proj_pos= vec4(0.0);

	//project our 3D position to the shadowmap //SHADOW
	
	if(u_flag==1){
		proj_pos =  u_shadow_viewproj * vec4( worldpos, 1.0 );
		if (u_light_type==1){  //SPOT
			vec3 vector_light = normalize( u_light_position - worldpos); 
			shadow_factor = getShadow(proj_pos, N,vector_light);
		}
		if (u_light_type==2){ //DIRECTIONAL
			vec3 vector_light = normalize(u_light_vector);
			shadow_factor= getShadow(proj_pos,N,vector_light); 
		}
		
	}
	
	//modulate direct light by light received
	vec3 lightPar= vec3(0.0);

	if (u_light_type == 0){ //POINT
		vec3 L = normalize( u_light_position - worldpos); 
		float NdotL = clamp( dot(L,N), 0.0,1.0 ); 

		float light_distance = length(u_light_position - worldpos);
		float att_factor = u_light_maxdist - light_distance;

		//normalize factor
		att_factor /= u_light_maxdist;

		//ignore negative values
		att_factor = max( att_factor, 0.0 );
		
		att_factor *= att_factor;
		light +=getPBR( worldpos,  N,  uv,color, metalness, roughness); 
		light += NdotL * u_light_color * att_factor;
		light *= u_light_intensity;
			
	}
	
	
	if (u_light_type == 1){ //SPOT
		vec3 L = normalize( u_light_position - worldpos); 
		float NdotL = clamp( dot(N,L), 0.0,1.0 ); 

		vec3 D=normalize(u_light_vector);
		float spotCosine = dot(D,-L); 
		
		if (degrees(acos(spotCosine)) <= (u_spotCosineCutoff))	{	
			float spotFactor = pow(spotCosine, u_spotExponent);
			light += NdotL * u_light_color*spotFactor*u_light_intensity* shadow_factor;
			//light += getPBR( worldpos,  N,  uv,color, metalness, roughness); 
			
		}
	
	} 
	if (u_light_type == 2){ //DIRECTIONAL
		vec3 L = normalize(u_light_vector);
		float NdotL = clamp( dot(L,N), 0.0,1.0); 
		
		light += NdotL * u_light_color*u_light_intensity* shadow_factor;
		light +=getPBR( worldpos,  N,  uv,color, metalness, roughness); 
		
	}

	//descartar punto si no esta en el frustrum 
	//color = pow(color,vec3(2.2)); 
	color *= light;
	color += texture2D(u_emissive_texture,uv).xyz; //emisive  
    FragColor = vec4(color,1.0);
	
}



\defferetBlend.fs
#version 330 core
precision highp float; 
const float PI = 3.14159265359;

//DEFERRET

uniform sampler2D u_depth_texture;
uniform vec2 u_iRes; 
uniform float u_time; 
uniform int u_factor;

//BLEND

uniform sampler2D u_texture;
uniform vec4 u_color;

in vec2 v_uv;
in vec3 v_world_position;
in vec3 v_normal;
uniform mat4 u_model;

//LIGHT
uniform vec3 u_light_vector;
uniform vec3 u_light_position;
uniform vec3 u_light_color;
uniform float u_light_intensity;
uniform float u_spotExponent;
uniform float u_spotCosineCutoff;
uniform int u_light_type;
uniform float u_light_maxdist;

uniform vec3 u_ambient_light;
uniform int u_gamma;
uniform vec3 u_camera_position;

//SHADOW

uniform mat4 u_shadow_viewproj;
uniform float u_bias;
uniform sampler2D shadowmap;
uniform float u_shadowmap_width;
uniform float u_shadowmap_height;
uniform sampler2DShadow u_shadowmap_AA;
uniform int u_is_shadow_AA;
uniform int u_is_front_shadow;
uniform int u_flag;

//PBR

uniform sampler2D u_emissive_texture;
uniform int u_is_emissive;
uniform float u_emissive_factor;
uniform sampler2D u_roughness_texture;
uniform float u_roughness_factor;
uniform float u_metalic_factor;

//SSAO
uniform sampler2D u_ao_texture;
uniform int u_is_ssao;

layout(location = 0) out vec4 FragColor;

vec3 L = vec3(0.0);
float shadow_factor = 1.0;
float NdotL=0;
vec2 shadow_uv;
float real_depth;
float att_factor=1;
float spotFactor=1;
vec3 light = vec3(0.0);



// Geometry Term: Geometry masking/shadowing due to microfacets
float GGX(float NdotV, float k){
    return NdotV / (NdotV * (1.0 - k) + k);
}
    
float G_Smith( float NdotV, float NdotL, float roughness)
{
    float k = pow(roughness + 1.0, 2.0) / 8.0;
    return GGX(NdotL, k) * GGX(NdotV, k);
}

vec3 F_Schlick( const in float VoH, const in vec3 f0)
{
    float f = pow(1.0 - VoH, 5.0);
    return f0 + (vec3(1.0) - f0) * f;
}


float D_GGX ( const in float NoH, const in float linearRoughness )
{
    float a2 = linearRoughness * linearRoughness;
    float f = (NoH * NoH) * (a2 - 1.0) + 1.0;
    return a2 / (PI * f * f);
}
vec4 getEmissiveLight(vec2 uv, vec4 color) //Emissive texture
{	
	if (u_is_emissive == 1){
		color.xyz += texture2D( u_emissive_texture , uv * u_factor).xyz;
	}

	return color; 
}
//this is the cook torrance specular reflection model
vec3 specularBRDF( float roughness, vec3 f0, float NoH, float NoV, float NoL, float LoH )
{
	float a = roughness * roughness;

	// Normal Distribution Function
	float D = D_GGX( NoH, a );

    // Fresnel Function
    vec3 F = F_Schlick( LoH, f0 );

    // Visibility Function (shadowing/masking)
    float G = G_Smith( NoV, NoL, roughness );
        
    // Norm factor
    vec3 spec = D * G * F;
    spec /= (4.0 * NoL * NoV + 1e-6);

    return spec;
}


float getShadow( vec3 N, vec3 L) //SHADOW, get de shadow_factor
{
	vec4 proj_pos =  u_shadow_viewproj * vec4( v_world_position, 1.0 );
	//from homogeneus space to clip space
	vec2 shadow_uv = proj_pos.xy / proj_pos.w;
			
	//from clip space to uv space
	shadow_uv = shadow_uv * 0.5 + vec2(0.5);
			
	//get point depth (from -1 to 1)
	float NdotL = clamp(dot(N,L), 0.0, 1.0);
	float real_depth;
	if (u_is_front_shadow == 1){
		float adaptative_bias = u_bias * tan(acos(NdotL));
		adaptative_bias = clamp(adaptative_bias, 0.0, 1.0);
		real_depth = (proj_pos.z - adaptative_bias)/ proj_pos.w;		
	}
	else
		real_depth = (proj_pos.z - u_bias)/ proj_pos.w;		
	
	
	
	//normalize from [-1..+1] to [0..+1]
	real_depth = real_depth * 0.5 + 0.5;
			
	//read depth from depth buffer in [0..+1]
	float shadow_depth = texture2D( shadowmap, shadow_uv).x;
			
	//compute final shadow factor by comparing
				
	if( shadow_depth < real_depth - u_bias)
		shadow_factor = 0.0; 
	
	if (u_light_type == 2 ){ //directional
		//it is outside on the sides
		if( shadow_uv.x < 0.0 || shadow_uv.x > 1.0 || shadow_uv.y < 0.0 || shadow_uv.y > 1.0)
			return 1.0;

		//it is before near or behind far plane
		if(real_depth < 0.0 || real_depth > 1.0)
			return 1.0;
	}
	
	if(u_is_shadow_AA==1){
		float xOffset = 1.0/u_shadowmap_width;
		float yOffset = 1.0/u_shadowmap_height;

		float Factor = 0.0;

		for (int y = -1 ; y <= 1 ; y++) {
			for (int x = -1 ; x <= 1 ; x++) {
				vec2 Offsets = vec2(x * xOffset, y * yOffset);
				vec3 UVC = vec3(shadow_uv + Offsets, real_depth);
				Factor += texture(u_shadowmap_AA, UVC);
			}
		}

		return (0.5 + (Factor / 18.0));
	}
	else
		return shadow_factor;
}

vec3 getPBR(vec3 worldpos, vec3 N, vec2 uv, vec3 color, float metalness, float roughness)
{

//now do your illumination using worldpos and the normal..
	   

	vec3 L = normalize( u_light_position - worldpos); 
	vec3 V = normalize(u_camera_position - worldpos);
	vec3 H = normalize(L+V); //cambiado a la N

	float NoH = max( dot(N,H), 0.0 );
	float NoV = max( dot(N,V), 0.0 );
	float NoL = max( dot(N,L), 0.0 );
	float LoH = max( dot(L,H), 0.0 );
	
	vec3 f0 = color * metalness + (vec3(0.5) * (1.0- metalness));

	//metallic materials do not have diffuse
	vec3 diffuseColor = (1.0 - metalness) * color;

	//compute the specular
	vec3 Fr_d = specularBRDF(  roughness, f0, NoH, NoV, NoL, LoH);

	// Here we use the Burley, but you can replace it by the Lambert.
	//float linearRoughness = pow(roughness,0.5);

	vec3 Fd_d = diffuseColor * NoL; 
	vec3 direct = Fr_d + Fd_d;
	//add diffuse and specular reflection
	
	return direct; 
}

vec3 getDirectionalLight(vec3 light, float shadow_factor, vec2 uv, float metalness, float roughness) //DIRECTIONAL LIGHT
{
	L = normalize(u_light_vector);
	vec3 N = normalize( v_normal);
	NdotL = clamp( dot(L,N), 0.0,1.0 ); 
	light += NdotL * u_light_color*u_light_intensity* shadow_factor;
	//light +=getPBR( v_world_position,  N,  uv, light, metalness, roughness); 

	return light;
}


vec3 getPointLight(vec3 light, float shadow_factor, vec2 uv, float metalness, float roughness) //POINT LIGHT
{
	vec3 N = normalize( v_normal);
	L = normalize( u_light_position - v_world_position);
	//compute distance
	float light_distance = length(u_light_position - v_world_position );

	//compute a linear attenuation factor
	att_factor = u_light_maxdist - light_distance;

	//normalize factor
	att_factor /= u_light_maxdist;

	//ignore negative values
	att_factor = max( att_factor, 0.0 );
	NdotL = clamp( dot(L,N), 0.0,1.0 );
	light += NdotL * u_light_color * u_light_intensity * att_factor;
	//light +=getPBR( v_world_position,  N,  uv,light, metalness, roughness); 
	return light; 
}

vec3 getSpotLight(vec3 light,float shadow_factor, vec2 uv, float metalness, float roughness) //SPOT LIGHT
{
	L = normalize( u_light_position - v_world_position); 
	vec3 N = normalize( v_normal);
	NdotL = clamp( dot(L,N), 0.0,1.0 ); 
	vec3 D=normalize(u_light_vector);
	float spotCosine = dot(D,-L); 

	if (degrees(acos(spotCosine)) <= (u_spotCosineCutoff))	{	
		float spotFactor = pow(spotCosine, u_spotExponent);
		light += NdotL * u_light_color*spotFactor*u_light_intensity* shadow_factor;
		//light+=getPBR( v_world_position,  N,  uv,light, metalness, roughness); 
			
	}
	
	return light;
}
vec3 getOclussionLight(vec3 light, vec2 uv, vec3 ambientL ) //Oclussion texture
{
	/*if (u_is_oclussion == 1){
		ambientL *= texture2D( u_oclussion, uv * u_factor).x;
	}*/
	light += ambientL;

	return light; 
}
vec3 getAmbientLight() //AMBIENT LIGHT
{
	vec3 ambientLight = u_ambient_light ;
	if (u_is_ssao ==1 )
	{
		//we need the uv for the pixel in screen position
		vec2 screenuv = gl_FragCoord.xy * u_iRes;

		//read the ao_factor for this pixel
		float ao_factor = texture( u_ao_texture, screenuv ).x;

		//we could play with the curve to have more control
		ao_factor = pow( ao_factor, 3.0 );

		//weight the ambient light by it
		ambientLight = u_ambient_light * ao_factor;
	}
	return ambientLight;
}

void main(){
	vec4 color = u_color;
	vec2 uv = v_uv;
	vec2 uv_deferred = gl_FragCoord.xy * u_iRes.xy; //extract uvs from pixel screenpos
	float depth = texture( u_depth_texture, uv_deferred ).x;
	color *= texture(u_texture, uv*u_factor);
	
	color *= vec4( getAmbientLight(),1.0);
	vec3 N = normalize(v_normal);
	if (depth==1.0)
		discard;

	float roughness = (texture( u_roughness_texture, uv)* u_roughness_factor).y;
	float metallic = (texture( u_roughness_texture, uv)* u_metalic_factor).z;
	//shadow
	if(u_flag==1){
		
		if (u_light_type==1){  //SPOT
			vec3 vector_light = normalize( u_light_position - v_world_position); 
			shadow_factor= getShadow(N,vector_light);
		}
		if (u_light_type==2){ //DIRECTIONAL
			vec3 vector_light = normalize(u_light_vector);
			shadow_factor= getShadow(N,vector_light); 
		}
		
	}
	if (u_light_type ==0){  //POINT
		light=getPointLight(light,shadow_factor,  uv,  metallic,  roughness);
		
	}
	if (u_light_type==1){  //SPOT
		light=getSpotLight(light, shadow_factor,  uv,  metallic,  roughness);
	}
	if (u_light_type==2){ //DIRECTIONAL
		light=getDirectionalLight(light, shadow_factor,  uv,  metallic,  roughness);
	
	}
	color.xyz *= light;

	color = getEmissiveLight( uv , color);

	FragColor = color;

}


\ssao.fs
#version 330 core
precision highp float; 

in vec2 v_uv;

uniform sampler2D u_depth_texture; //bien
uniform mat4 u_inverse_viewprojection;
uniform mat4 u_viewprojection;
uniform sampler2D u_normal_texture; //bien
uniform vec3 u_camera_position; 
uniform vec2 u_iRes; 
uniform vec3 u_points [64];
uniform vec2 u_camera_nearfar;
out vec4 FragColor;
//from this github repo
mat3 cotangent_frame(vec3 N, vec3 p, vec2 uv)
{
	// get edge vectors of the pixel triangle
	vec3 dp1 = dFdx( p );
	vec3 dp2 = dFdy( p );
	vec2 duv1 = dFdx( uv );
	vec2 duv2 = dFdy( uv );
	
	// solve the linear system
	vec3 dp2perp = cross( dp2, N );
	vec3 dp1perp = cross( N, dp1 );
	vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
	vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
 
	// construct a scale-invariant frame 
	float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
	return mat3( T * invmax, B * invmax, N );
}

void main(){
	//we want to center the sample in the center of the pixel
	vec2 uv = v_uv + u_iRes * 0.5;

	//read depth from depth buffer
	float depth = texture( u_depth_texture, uv ).x;
	vec3 normal = texture( u_normal_texture, uv ).xyz * 2.0 - 1.0;
	
	//ignore pixels in the background
	if(depth >= 1.0)
	{
		FragColor = vec4(1.0);
		return;
	}

	//create screenpos with the right depth
	vec4 screen_position = vec4(uv*2.0 - vec2(1.0), depth*2.0 - 1.0,1.0);

	//reproject
	vec4 proj_worldpos = u_inverse_viewprojection * screen_position;
	vec3 worldpos = proj_worldpos.xyz / proj_worldpos.w;
	
	//lets use 64 samples
	const int samples = 64;
	int num = samples; //num samples that passed the are outside

	//for every sample around the point
	for( int i = 0; i < samples; ++i )
	{	
		//to create the matrix33 to convert from tangent to world
		mat3 rotmat = cotangent_frame( normal, worldpos, uv );

		//rotate a point is easy
		vec3 rotated_point = rotmat * u_points[i];

		//compute is world position using the random
		vec3 p = worldpos + rotated_point * 5.0;
		//find the uv in the depth buffer of this point
		vec4 proj = u_viewprojection * vec4(p,1.0);
		proj.xy /= proj.w; //convert to clipspace from homogeneous
		//apply a tiny bias to its z before converting to clip-space
		proj.z = (proj.z - 0.005) / proj.w; 
		proj.xyz = proj.xyz * 0.5 + vec3(0.5); //to [0..1] coord de textura
		//read p true depth
		float pdepth = texture( u_depth_texture, proj.xy ).x;
		//compare true depth with its depth
		if( pdepth < proj.z ) //if true depth smaller, is inside
			num--; //remove this point from the list of visible occlusion
	}

	//finally, compute the AO factor accordingly
	float ao = float(num) / float(samples);
	FragColor = vec4(ao, ao, ao, 1.0); //se ve mejor
	//FragColor = vec4(ao);


}

\ssao_blur.fs
#version 330 core
precision highp float; 

uniform vec2 u_offset;
uniform sampler2D u_texture;
in vec2 v_uv;
out vec4 FragColor;

void main(){

vec2 uv = v_uv ; 
vec4 color = vec4(0.0);

for (int i = -2 ; i <= 2 ; ++i)
	for (int j = -2 ; j <= 2 ; ++j)
		color += texture2D(u_texture , uv+ u_offset * vec2 (i ,j) + vec2 (0.5) * u_offset); 
		
color /= 25.0; //num of samples
FragColor = color;

}

\probes.fs
#version 330 core


in vec3 v_position;
in vec3 v_world_position;
in vec2 v_uv;
in vec4 v_color;
in vec3 v_normal;

uniform vec3 u_coeffs[9];
uniform sampler2D u_depth_texture;
uniform vec2 u_iRes;
uniform mat4 u_viewprojection;

const float Pi = 3.141592654;
const float CosineA0 = Pi;
const float CosineA1 = (2.0 * Pi) / 3.0;
const float CosineA2 = Pi * 0.25;
struct SH9 { float c[9]; }; //to store weights
struct SH9Color { vec3 c[9]; } ; //to store colors

out  vec4 FragColor;
void SHCosineLobe(in vec3 dir, out SH9 sh) //SH9
{
	// Band 0
	sh.c[0] = 0.282095 * CosineA0;
	// Band 1
	sh.c[1] = 0.488603 * dir.y * CosineA1; 
	sh.c[2] = 0.488603 * dir.z * CosineA1;
	sh.c[3] = 0.488603 * dir.x * CosineA1;
	// Band 2
	sh.c[4] = 1.092548 * dir.x * dir.y * CosineA2;
	sh.c[5] = 1.092548 * dir.y * dir.z * CosineA2;
	sh.c[6] = 0.315392 * (3.0 * dir.z * dir.z - 1.0) * CosineA2;
	sh.c[7] = 1.092548 * dir.x * dir.z * CosineA2;
	sh.c[8] = 0.546274 * (dir.x * dir.x - dir.y * dir.y) * CosineA2;
}

vec3 ComputeSHIrradiance(in vec3 normal, in SH9Color sh)
{
	// Compute the cosine lobe in SH, oriented about the normal direction
	SH9 shCosine;
	SHCosineLobe(normal, shCosine);
	// Compute the SH dot product to get irradiance
	vec3 irradiance = vec3(0.0);
	for(int i = 0; i < 9; ++i)
		irradiance += sh.c[i] * shCosine.c[i];

	return irradiance;
}
void main(){
	//vec2 uv = v_uv;
	vec2 uv_deferred = (gl_FragCoord.xy)*u_iRes.xy; //extract uvs from pixel screenpos
	float depth = texture( u_depth_texture, uv_deferred ).x;
	vec4 screen_position = vec4(uv_deferred.x*2.0-1.0 ,uv_deferred.y*2.0-1.0, depth*2.0- 1.0,1.0);
	
	vec3 probe_world_pos = v_world_position;
	vec4 probe_proj = u_viewprojection * vec4 (probe_world_pos,1.0);
	probe_proj.z = (probe_proj.z - 0.005) / probe_proj.w ; 
	probe_proj.xy /= probe_proj.w; //convert to clipspace from homogeneous
	//apply a tiny bias to its z before converting to clip-space
	probe_proj.xyz = probe_proj.xyz * 0.5 + vec3(0.5); //to [0..1] coord de textura
	//read p true depth
	if(screen_position.z < probe_proj.z )
		discard;
	
	SH9Color values ;
	for (int i=0; i < 9; i++)
		values.c[i] = u_coeffs[i];
	vec3 N = normalize(v_normal);
	vec3 irradiance = ComputeSHIrradiance(N, values);
	FragColor = vec4(irradiance,1.0);
}

\deferret_irradiance.fs

#version 330 core
precision highp float; 
const float PI = 3.14159265359;

//DEFERRET
uniform sampler2D u_color_texture;
uniform sampler2D u_normal_texture;
uniform sampler2D u_position_texture;
uniform sampler2D u_depth_texture;
uniform sampler2D u_emissive_texture;

uniform mat4 u_inverse_viewprojection;
uniform vec2 u_iRes; 
uniform float u_time; 
uniform mat4 u_viewprojection;

//IRADIANCE
uniform vec3 u_irr_end;
uniform vec3 u_irr_start;
uniform vec3 u_irr_delta;
uniform vec3 u_irr_dims;
uniform float u_irr_normal_distance;
uniform int u_num_probes;
uniform sampler2D u_probes_texture;

//PHONG
uniform int u_factor;
uniform vec3 u_ambient_light;
uniform vec3 u_light_position;
uniform int u_light_type;
uniform float u_light_intensity;
uniform vec3 u_light_color;
uniform float u_light_maxdist;
uniform vec3 u_light_vector;
uniform float u_spotCosineCutoff;
uniform float u_spotExponent;
uniform mat4 u_model;
uniform int u_gamma;

uniform vec3 u_camera_position;

//SHADOW
uniform sampler2D shadowmap;
uniform mat4 u_shadow_viewproj;
uniform float u_bias;
uniform int u_flag;
uniform sampler2DShadow u_shadowmap_AA;
uniform float u_shadowmap_width;
uniform float u_shadowmap_height;
uniform int u_is_shadow_AA;
uniform int u_is_front_shadow;

//SSAO
uniform sampler2D u_ao_texture;
uniform int u_is_ssao;

const float Pi = 3.141592654;
const float CosineA0 = Pi;
const float CosineA1 = (2.0 * Pi) / 3.0;
const float CosineA2 = Pi * 0.25;
struct SH9 { float c[9]; }; //to store weights
struct SH9Color { vec3 c[9]; } ; //to store colors

vec3 L = vec3(0.0);
float shadow_factor = 1.0;
float NdotL=0;
vec2 shadow_uv;
float real_depth;
float att_factor=1;
float spotFactor=1;

layout(location = 0) out vec4 FragColor;

void SHCosineLobe(in vec3 dir, out SH9 sh) //SH9
{
	// Band 0
	sh.c[0] = 0.282095 * CosineA0;
	// Band 1
	sh.c[1] = 0.488603 * dir.y * CosineA1; 
	sh.c[2] = 0.488603 * dir.z * CosineA1;
	sh.c[3] = 0.488603 * dir.x * CosineA1;
	// Band 2
	sh.c[4] = 1.092548 * dir.x * dir.y * CosineA2;
	sh.c[5] = 1.092548 * dir.y * dir.z * CosineA2;
	sh.c[6] = 0.315392 * (3.0 * dir.z * dir.z - 1.0) * CosineA2;
	sh.c[7] = 1.092548 * dir.x * dir.z * CosineA2;
	sh.c[8] = 0.546274 * (dir.x * dir.x - dir.y * dir.y) * CosineA2;
}


vec3 ComputeSHIrradiance(vec3 normal, SH9Color sh){
	// Compute the cosine lobe in SH, oriented about the normal direction
	SH9 shCosine;
	SHCosineLobe(normal, shCosine);
	// Compute the SH dot product to get irradiance
	vec3 irradiance = vec3(0.0);
	for(int i = 0; i < 9; ++i)
		irradiance += sh.c[i] * shCosine.c[i];

	return irradiance;
}

vec3 getIrradiance(vec3 worldpos ,vec3 N){

	//computing nearest probe index based on world position
	vec3 irr_range = u_irr_end - u_irr_start;
	vec3 grid_pos = worldpos - u_irr_start;
	vec3 irr_local_pos = clamp( worldpos - u_irr_start 
	+ N * u_irr_normal_distance*u_irr_delta , //offset a little
	 vec3(0.0), irr_range );
	

	//convert from world pos to grid pos
	vec3 irr_norm_pos = irr_local_pos / u_irr_delta;

	//round values as we cannot fetch between rows for now
	vec3 local_indices = round( irr_norm_pos );

	//compute in which row is the probe stored
	float row = local_indices.x +  local_indices.y * u_irr_dims.x + local_indices.z * u_irr_dims.x * u_irr_dims.y;

	//find the UV.y coord of that row in the probes texture
	float row_uv = (row + 1.0) / (u_num_probes + 1.0);

	SH9Color sh;

	//fill the coefficients
	const float d_uvx = 1.0 / 9.0;
	for(int i = 0; i < 9; ++i)
	{
		vec2 coeffs_uv = vec2( (float(i)+0.5) * d_uvx, row_uv );
		sh.c[i] = texture( u_probes_texture, coeffs_uv).xyz;
	}

	//now we can use the coefficients to compute the irradiance
	vec3 irradiance = ComputeSHIrradiance( N, sh );


	return irradiance;
} 

vec3 getAmbientLight(vec2 uv) //AMBIENT LIGHT
{
	vec3 ambientLight = vec3(0.0);
	if (u_is_ssao ==1 )
	{
		//we need the uv for the pixel in screen position
		vec2 screenuv = gl_FragCoord.xy * u_iRes;

		//read the ao_factor for this pixel
		float ao_factor = texture( u_ao_texture, screenuv ).x;

		//we could play with the curve to have more control
		ao_factor = pow( ao_factor, 3.0 );

		//weight the ambient light by it
		ambientLight += u_ambient_light * ao_factor;
	}
	else 
		ambientLight += texture(u_emissive_texture, uv).w * u_ambient_light;

		
	return ambientLight;
}
// Geometry Term: Geometry masking/shadowing due to microfacets
float GGX(float NdotV, float k){
    return NdotV / (NdotV * (1.0 - k) + k);
}
    
float G_Smith( float NdotV, float NdotL, float roughness)
{
    float k = pow(roughness + 1.0, 2.0) / 8.0;
    return GGX(NdotL, k) * GGX(NdotV, k);
}

vec3 F_Schlick( const in float VoH, const in vec3 f0)
{
    float f = pow(1.0 - VoH, 5.0);
    return f0 + (vec3(1.0) - f0) * f;
}


float D_GGX ( const in float NoH, const in float linearRoughness )
{
    float a2 = linearRoughness * linearRoughness;
    float f = (NoH * NoH) * (a2 - 1.0) + 1.0;
    return a2 / (PI * f * f);
}

//this is the cook torrance specular reflection model
vec3 specularBRDF( float roughness, vec3 f0, float NoH, float NoV, float NoL, float LoH )
{
	float a = roughness * roughness;

	// Normal Distribution Function
	float D = D_GGX( NoH, a );

    // Fresnel Function
    vec3 F = F_Schlick( LoH, f0 );

    // Visibility Function (shadowing/masking)
    float G = G_Smith( NoV, NoL, roughness );
        
    // Norm factor
    vec3 spec = D * G * F;
    spec /= (4.0 * NoL * NoV + 1e-6);

    return spec;
}


vec3 getPointLight(vec3 color, float shadow_factor, vec3 worldpos, vec3 N) //POINT LIGHT
{
	vec3 lightPos = u_light_position;
	vec3 L = (lightPos - worldpos);
	float dist = length(L);
	L /= dist; 
	float NdotL = clamp(dot(N,L),0.0,1.0);

	color += NdotL * u_light_color * u_light_intensity;
	return color; 
}

float getShadow(vec4 proj_pos, vec3 N, vec3 L) //SHADOW, get de shadow_factor
{

	//from homogeneus space to clip space
	shadow_uv = proj_pos.xy / proj_pos.w;
			
	//from clip space to uv space
	shadow_uv = shadow_uv * 0.5 + vec2(0.5);
			
	//get point depth (from -1 to 1)
	float NdotL = clamp(dot(N,L), 0.0, 1.0);
	float real_depth;
	if (u_is_front_shadow == 1){
		float adaptative_bias = u_bias * tan(acos(NdotL));
		adaptative_bias = clamp(adaptative_bias, 0.0, 1.0);
		real_depth = (proj_pos.z - adaptative_bias)/ proj_pos.w;		
	}
	else
		real_depth = (proj_pos.z - u_bias)/ proj_pos.w;		
	
	
	
	//normalize from [-1..+1] to [0..+1]
	real_depth = real_depth * 0.5 + 0.5;
			
	//read depth from depth buffer in [0..+1]
	float shadow_depth = texture2D( shadowmap, shadow_uv).x;
			
	//compute final shadow factor by comparing
				
	if( shadow_depth < real_depth - u_bias)
		shadow_factor = 0.0; 
	
	if (u_light_type == 2 ){ //directional
		//it is outside on the sides
		if( shadow_uv.x < 0.0 || shadow_uv.x > 1.0 || shadow_uv.y < 0.0 || shadow_uv.y > 1.0)
			return 1.0;

		//it is before near or behind far plane
		if(real_depth < 0.0 || real_depth > 1.0)
			return 1.0;
	}
	
	if(u_is_shadow_AA==1){
		float xOffset = 1.0/u_shadowmap_width;
		float yOffset = 1.0/u_shadowmap_height;

		float Factor = 0.0;

		for (int y = -1 ; y <= 1 ; y++) {
			for (int x = -1 ; x <= 1 ; x++) {
				vec2 Offsets = vec2(x * xOffset, y * yOffset);
				vec3 UVC = vec3(shadow_uv + Offsets, real_depth);
				Factor += texture(u_shadowmap_AA, UVC);
			}
		}

		return (0.5 + (Factor / 18.0));
	}
	else
		return shadow_factor;
}

vec3 getPBR(vec3 worldpos, vec3 N, vec2 uv, vec3 color, float metalness, float roughness)
{

//now do your illumination using worldpos and the normal..
	   

	vec3 L = normalize( u_light_position - worldpos); 
	vec3 V = normalize(u_camera_position - worldpos);
	vec3 H = normalize(L+V); //cambiado a la N

	float NoH = max( dot(N,H), 0.0 );
	float NoV = max( dot(N,V), 0.0 );
	float NoL = max( dot(N,L), 0.0 );
	float LoH = max( dot(L,H), 0.0 );
	
	vec3 f0 = color * metalness + (vec3(0.5) * (1.0- metalness));

	//metallic materials do not have diffuse
	vec3 diffuseColor = (1.0 - metalness) * color;

	//compute the specular
	vec3 Fr_d = specularBRDF(  roughness, f0, NoH, NoV, NoL, LoH);

	// Here we use the Burley, but you can replace it by the Lambert.
	//float linearRoughness = pow(roughness,0.5);

	vec3 Fd_d = diffuseColor * NoL; 
	vec3 direct = Fr_d + Fd_d;
	//add diffuse and specular reflection
	
	return direct; 
}

void main()
{
	
	vec2 uv = gl_FragCoord.xy * u_iRes.xy; //extract uvs from pixel screenpos
	float factor = texture(u_position_texture,uv).w;
    vec3 color = texture( u_color_texture, uv * factor).xyz;
    float depth = texture( u_depth_texture, uv ).x;
    vec3 N = texture( u_normal_texture, uv ).xyz * 2.0 - 1.0;
    //N = normalize(N); //always normalize in case of data loss
    vec4 screen_pos = vec4(uv.x*2.0-1.0, uv.y*2.0-1.0, depth*2.0-1.0, 1.0);
    vec4 proj_worldpos = u_inverse_viewprojection * screen_pos;
    vec3 worldpos = proj_worldpos.xyz / proj_worldpos.a;

	vec3 light = vec3(1.0);
	light *= getAmbientLight(uv); //oclusive and ambient

	if (depth==1.0)
		discard; 
	
	//PBR
	vec3 direct = vec3(0.0);
	float metalness = texture2D( u_color_texture, uv ).w;
	float roughness = texture2D( u_normal_texture, uv ).w;

	vec4 proj_pos= vec4(0.0);

	//project our 3D position to the shadowmap //SHADOW
	
	if(u_flag==1){
		proj_pos =  u_shadow_viewproj * vec4( worldpos, 1.0 );
		if (u_light_type==1){  //SPOT
			vec3 vector_light = normalize( u_light_position - worldpos); 
			shadow_factor= getShadow(proj_pos, N,vector_light);
		}
		if (u_light_type==2){ //DIRECTIONAL
			vec3 vector_light = normalize(-u_light_vector);
			shadow_factor= getShadow(proj_pos,N,vector_light); 
		}
		
	}
	
	//modulate direct light by light received
	vec3 lightPar= vec3(0.0);

	if (u_light_type == 0){ //POINT
		vec3 L = normalize( u_light_position - worldpos); 
		float NdotL = clamp( dot(L,N), 0.0,1.0 ); 

		float light_distance = length(u_light_position - worldpos);
		float att_factor = u_light_maxdist - light_distance;

		//normalize factor
		att_factor /= u_light_maxdist;

		//ignore negative values
		att_factor = max( att_factor, 0.0 );
		att_factor*= att_factor;
		light +=getPBR( worldpos,  N,  uv,color, metalness, roughness); 
		light += NdotL * u_light_color * att_factor;
		light *= u_light_intensity;

				
	}
	
	
	if (u_light_type == 1){ //SPOT
		vec3 L = normalize( u_light_position - worldpos); 
		float NdotL = clamp( dot(N,L), 0.0,1.0 ); 

		vec3 D=normalize(u_light_vector);
		float spotCosine = dot(D,-L); 
		
		if (degrees(acos(spotCosine)) <= (u_spotCosineCutoff))	{	
			float spotFactor = pow(spotCosine, u_spotExponent);
			light += NdotL * u_light_color*spotFactor*u_light_intensity* shadow_factor;
			light += getPBR( worldpos,  N,  uv,color, metalness, roughness); 
			
		}
	
	} 
	if (u_light_type == 2){ //DIRECTIONAL
		vec3 L = normalize(u_light_vector);
		float NdotL = clamp( dot(L,N), 0.0,1.0); 
		
		light += NdotL * u_light_color*u_light_intensity* shadow_factor;
		light +=getPBR( worldpos,  N,  uv,color, metalness, roughness); 
	}

	//descartar punto si no esta en el frustrum 
	//color = pow(color,vec3(2.2)); 
	color *=light;
	color += getIrradiance(worldpos , N)*0.2;
	
	color += texture2D(u_emissive_texture,uv).xyz; //emisive  
    FragColor = vec4(color,1.0);
	
}


\skybox.fs
#version 330 core

in vec3 v_world_position;

uniform samplerCube u_texture;
uniform vec3 u_camera_position;

out vec4 FragColor;

void main()
{
	vec3 V = normalize( u_camera_position - v_world_position );

	FragColor = textureLod( u_texture, V ,0.0)*0.2;
}

\ReflectionProbes.fs
#version 330 core
in vec3 v_world_position;
in vec3 v_normal;

uniform vec3 u_camera_position;
uniform samplerCube u_texture;

out vec4 FragColor;
void main()
{
	vec3 N = normalize( v_normal );
	vec3 V = normalize( u_camera_position - v_world_position );

	vec3 R = reflect( -V, N );

	FragColor = vec4 (textureLod( u_texture, R ,0.0).xyz*0.2,1.0);
}

\volumetricDirectional.fs

#version 330 core

uniform sampler2D u_depth_texture;
uniform mat4 u_inverse_viewprojection;
uniform vec3 u_ambient_light;
uniform vec3 u_camera_position;
uniform vec2 u_iRes;

in vec2 v_uv;
out vec4 FragColor;
void main(){

	vec2 uv = gl_FragCoord.xy * u_iRes;
	float depth = texture (u_depth_texture,uv).x;
	if(depth == 1.0)
		discard;
	vec4 screen_position = vec4(uv.x*2.0-1.0,uv.y*2.0,depth*2.0-1.0,1.0);
	vec4 proj_worldpos = u_inverse_viewprojection* screen_position;
	vec3 worldpos = proj_worldpos.xyz/proj_worldpos.w;
	float dist = length(u_camera_position - worldpos)*0.1;
	FragColor = vec4(1.0,1.0,1.0,1.0);
	
}